<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js canvas - geometry - terrain</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        background-color: #bfd1e5;
        margin: 0px;
        overflow: hidden;
      }
    </style>
  </head>
  <body>

    <div id="container"><br /><br /><br /><br /><br />Generating...</div>

    <script src="three.min.js"></script>

    <script src="ImprovedNoise.js"></script>

    <script>

      var container;

      var camera, scene, renderer;

      var mesh;

      var mouseX = 0, mouseY = 0;

      var windowHalfX = window.innerWidth / 2;
      var windowHalfY = window.innerHeight / 2;

      init();
      animate();

      function init() {
        container = document.getElementById( 'container' );

        camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.x = 1500;
        camera.position.y = 1500;
        camera.position.z = 500;

        scene = new THREE.Scene();

        var data = generateHeight(512, 512);
        var texture = new THREE.Texture(generateTexture( data, 512, 512 ));
        texture.needsUpdate = true;

        var material = new THREE.MeshBasicMaterial( { map: texture, overdraw: true } );

        var quality = 16, step = 512 / quality;

        var plane = new THREE.PlaneGeometry( 2000, 2000, quality - 1, quality - 1 );
        plane.applyMatrix( new THREE.Matrix4().makeRotationX( - Math.PI / 2 ) );

        for ( var i = 0, l = plane.vertices.length; i < l; i ++ ) {

          var x = i % quality, y = ~~ ( i / quality );
          plane.vertices[ i ].y = data[ ( x * step ) + ( y * step ) * 512 ] * 2 - 128;

        }

        plane.computeCentroids();

        mesh = new THREE.Mesh( plane, material );
        scene.add( mesh );

        renderer = new THREE.CanvasRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );

        container.innerHTML = "";
        container.appendChild(renderer.domElement);

        //document.addEventListener( 'mousemove', onDocumentMouseMove, false );

        window.addEventListener( 'resize', onWindowResize, false );
      }

      function onWindowResize() {
        windowHalfX = window.innerWidth / 2;
        windowHalfY = window.innerHeight / 2;

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
      }

      function generateHeight( width, height ) {
        var data = Float32Array ? new Float32Array( width * height ) : [], perlin = new ImprovedNoise(),
        size = width * height, quality = 2, z = Math.random() * 100;

        for ( var i = 0; i < size; i ++ ) {
          data[ i ] = 0
        }

        for ( var j = 0; j < 4; j ++ ) {
          quality *= 4;
          for ( var i = 0; i < size; i ++ ) {
            var x = i % width, y = ~~ ( i / width );
            data[ i ] += Math.floor( Math.abs( perlin.noise( x / quality, y / quality, z ) * 0.5 ) * quality + 10 );
          }
        }

        return data;
      }

      function generateTexture(data, width, height) {
        var canvas, context, image, imageData,
        level, diff, vector3, sun, shade;

        vector3 = new THREE.Vector3( 0, 0, 0 );

        sun = new THREE.Vector3( 1, 1, 1 );
        sun.normalize();

        canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;

        context = canvas.getContext( '2d' );
        context.fillStyle = '#000';
        context.fillRect( 0, 0, width, height );

        image = context.getImageData( 0, 0, width, height );
        imageData = image.data;

        for ( var i = 0, j = 0, l = imageData.length; i < l; i += 4, j ++  ) {

          vector3.x = data[ j - 1 ] - data[ j + 1 ];
          vector3.y = 2;
          vector3.z = data[ j - width ] - data[ j + width ];
          vector3.normalize();

          shade = vector3.dot( sun );

          imageData[ i ] = ( 96 + shade * 128 ) * ( data[ j ] * 0.007 );
          imageData[ i + 1 ] = ( 32 + shade * 96 ) * ( data[ j ] * 0.007 );
          imageData[ i + 2 ] = ( shade * 96 ) * ( data[ j ] * 0.007 );

          //imageData[i] = 127;
          //imageData[i + 1] = 127;
          //imageData[i + 2] = 127;
        }

        context.putImageData(image, 0, 0);

        return canvas;
      }

      function onDocumentMouseMove(event) {
        mouseX = event.clientX - windowHalfX;
        mouseY = event.clientY - windowHalfY;
      }

      //

      function animate() {
        requestAnimationFrame(animate);

        render();
      }

      function render() {

        //camera.position.x += ( mouseX - camera.position.x ) * 0.05;
        //camera.position.y += ( - mouseY - camera.position.y ) * 0.05;
        camera.lookAt(scene.position);

        renderer.render( scene, camera );

      }


    </script>

  </body>
</html>
