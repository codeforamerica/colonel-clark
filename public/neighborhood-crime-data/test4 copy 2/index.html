<script src="three.min.js"></script>

<style>
  body {
    margin: 0;
    overflow: hidden;
  }
  canvas {
    outline: 2px solid red;
  }
</style>

<script>
    window.requestAnimFrame = (function(callback){
        return window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function(callback){
            window.setTimeout(callback, 1000 / 60);
        };
    })();
 
    function animate(lastTime, angularSpeed, three){
      // update
      var date = new Date();
      var time = date.getTime();
      var timeDiff = time - lastTime;
      var angleChange = angularSpeed * timeDiff * 2 * Math.PI / 1000;

      three.cube.rotation.y += angleChange;
      three.cube2.rotation.y += angleChange;

      lastTime = time;

      // render
      three.renderer.render(three.scene, three.camera);

      // request new frame
      requestAnimFrame(function(){
          animate(lastTime, angularSpeed, three);
      });
    }
 
    window.onload = function(){
        var angularSpeed = 0.1 / 2; // revolutions per second
        var lastTime = 0;
 
        // renderer
        var renderer = new THREE.WebGLRenderer({
          antialias   : true, // to get smoother output          
        });
        renderer.shadowMapEnabled = true;
        renderer.shadowMapSoft    = true;
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
 
        // camera
        var camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 1, 1000);
        camera.position.x = 20;
        camera.position.y = 20;
        camera.position.z = 1000;

        camera.rotation.x = 0.1;
        camera.rotation.y = 0.1;
        camera.rotation.z = 0.1;

        // scene
        var scene = new THREE.Scene();
 
        // material
        var material = new THREE.MeshLambertMaterial({
            map: THREE.ImageUtils.loadTexture("crate.jpg")
        });
 
        // cube
        var cube = new THREE.Mesh(new THREE.CubeGeometry(200, 200, 200), material);
        cube.overdraw = true;
        //cube.castShadow   = true;
        //cube.receiveShadow  = true;
        //scene.add(cube);

        cube.position.z = 600;
        cube.position.x = 200;


        //var material = new THREE.MeshLambertMaterial({ color: 0xaaaaaa });

        var material = new THREE.MeshLambertMaterial({
            map: THREE.ImageUtils.loadTexture("crate.jpg")
        });

        var cube2 = new THREE.Mesh(new THREE.CubeGeometry(200, 200, 200), material);
        cube2.overdraw = true;
        //cube2.castShadow   = true;
        //cube2.receiveShadow  = true;
        //scene.add(cube2);

        cube2.position.x = -400;
        cube2.position.z = 600;

        //plane = new Plane(256, 256, 256, 256);

        var PLANE_SIZE = 800;

        var material  = new THREE.MeshPhongMaterial({
          ambient   : 0x444444,
          color   : 0x8844AA,
          shininess : 300, 
          specular  : 0x33AA33,
          shading   : THREE.SmoothShading
        });

        var plane = new THREE.Mesh(
            new THREE.PlaneGeometry(PLANE_SIZE, PLANE_SIZE, 32, 32),
            //new THREE.MeshBasicMaterial({ color: 0x0000ff })
            material
        );

        //var plane = new THREE.Plane(1000, 1000, 4, 4);

        plane.position.x = -200;
        plane.position.z = 150;
        plane.overdraw = true;

        plane.castShadow   = true;
        plane.receiveShadow  = true;

        plane.geometry.dynamic = true;

        scene.add(plane);        

        for (var i in plane.geometry.vertices) {
          var vertice = plane.geometry.vertices[i];

          var x = (vertice.x + PLANE_SIZE / 2) / PLANE_SIZE;
          var y = (vertice.y + PLANE_SIZE / 2) / PLANE_SIZE;

          var z = (Math.sin(x * 4) + Math.cos(y * 24)) * 100 + 50;

          vertice.z = z;
        }

        //plane.geometry.__dirtyVertices = true;
        //plane.geometry.__dirtyNormals = true;

        //camera.target = cube;
        //camera.target.position.copy(cube);
 
        // add subtle ambient lighting
        var ambientLight = new THREE.AmbientLight(0x222222);
        scene.add(ambientLight);
 
        // add directional light source
        //var directionalLight = new THREE.DirectionalLight(0xffffff);
        //directionalLight.position.set(100, 100, 100);//.normalize();
        //directionalLight.cameraVisible = true;
        //scene.add(directionalLight);

        var light = new THREE.SpotLight( 0xFFAA88, 2 );
        light.position.set( 0, 400, 1400 );
        light.target.position.set( 0, 300, 700 );
        light.shadowCameraNear    = 0.01;   
        light.castShadow    = true;
        light.shadowDarkness    = 0.5;
        //light.shadowCameraVisible = true;
        scene.add( light );
 
        // create wrapper object that contains three.js objects
        var three = {
            renderer: renderer,
            camera: camera,
            scene: scene,
            cube: cube,
            plane: plane,
            cube2: cube2
        };
 
        /*
         * wait for texture image to load before
         * starting the animation
         */ 
        var textureImg = new Image();
        textureImg.onload = function(){
            animate(lastTime, angularSpeed, three, this);
        };
        textureImg.src = "crate.jpg";

        globalThree = three;
    };
</script>